{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/cpp-notes-part-1-literals","result":{"data":{"post":{"__typename":"MdxPost","slug":"/cpp-notes-part-1-literals","title":"C++ Notes: Literals [Part-1]","date":"02.05.2020","tags":[{"name":"C++","slug":"c"}],"description":"literals","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"C++ Notes: Literals [Part-1]\",\n  \"date\": \"2020-05-02T00:00:00.000Z\",\n  \"slug\": \"/cpp-notes-part-1-literals\",\n  \"tags\": [\"C++\"],\n  \"description\": \"literals\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I had a long dream of learning C++ properly, and due the lockdown during Covid19 pandemic I finally had the chance to review my learnings and fix what I knew wrong. I will be writing notes on C++ to make my learnings persistent. They won't be in depth as other articles of C++ experts. I didn't get any chance to work anywhere as a C++ developer, there might be silly or grave mistakes here and there. For the time being, I will ignore those and just move along to maintain my flow.\"), mdx(\"h2\", null, \"References\"), mdx(\"p\", null, \"Most of the codes are inpired from the book \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leanpub.com/cpplibrary\"\n  }), \"The C++ Standard Library\"), \" by Rainer Grimm and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.cppreference.com/\"\n  }), \"C++ Reference\"), \". I really like his teaching and coding style. He published multiple outstanding C++ books.\"), mdx(\"p\", null, \"Let's begin, shall we?\"), mdx(\"h3\", null, \"Literals\"), mdx(CollapseComponent, {\n    heading: \"Literals\",\n    text: \"Literals are explicit values in the program.\",\n    mdxType: \"CollapseComponent\"\n  }), mdx(\"br\", null), mdx(\"p\", null, \"Value of literal is fixed, it can also be referred as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"constants\"), \". Literal can be value of basic types such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bool\"), \" etc.\"), mdx(\"p\", null, \"Built in C++ literals are shown below.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp:title=main.cpp\"\n  }), \"#include <iostream>\\n\\nint main(){\\n  // Unsigned integer\\n  int unsigned_int = u'U';\\n  // Hexadecimal\\n  int hex = 0x2b;\\n  // Raw string\\n  std::string raw = R\\\"(Raw String)\\\";\\n  std::cout << unsigned_int << \\\", \\\" << hex << \\\", \\\" << raw << std::endl;\\n}\\n\")), mdx(\"p\", null, \"Output\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"85, 42, Raw String\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Literals are not restricted to values, even \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"lambda\"), \" function can be a \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"function literal\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"lambda function[](std::string text) { return text.length(); }\\n\")), mdx(\"h3\", null, \"Raw string literals\"), mdx(\"p\", null, \"Anything between the delimiters of raw string becomes a part of the string.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"#include <iostream>\\n\\nconst char* string1 = R\\\"foo(\\n  Hello\\n  World\\n  )foo\\\";\\n\\nint main (){\\n  std::cout << string1 << std::endl;\\n}\\n\\n\")), mdx(\"p\", null, \"Output\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"\\n  Hello\\n  World\\n\\n\\n\")), mdx(\"h3\", null, \"Built in literals\"), mdx(\"p\", null, \"Let's see a self explanatory example.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"#include <iostream>\\n// We need to include chrono to work\\n#include <chrono>\\n\\n// We are going to use c++ standard library's chrono literals\\nusing namespace std::chrono_literals;\\n\\nint main(){\\n  // Let's declare 1 hour by using h literal\\n  std::chrono::hours one_hour = 1h;\\n  // Let's convert one hour to seconds\\n  auto time_in_seconds = std::chrono::duration_cast<std::chrono::seconds>(one_hour);\\n  std::cout << time_in_seconds.count() << std::endl;\\n}\\n\")), mdx(\"h4\", null, \"Output\"), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"3600\\n\")), mdx(\"br\", null), mdx(\"h4\", null, \"User defined literals\"), mdx(\"br\", null), mdx(\"p\", null, \"There are six major categories of literals in C++.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"integer\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"chracter\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"floating-point\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"string\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"boolean\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"pointer\")), mdx(\"h5\", null, \"User defined literal operator signatures\"), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"ReturnType operator \\\"\\\" _a(unsigned long long int);   // Literal operator for user-defined INTEGRAL literal\\nReturnType operator \\\"\\\" _b(long double);              // Literal operator for user-defined FLOATING literal\\nReturnType operator \\\"\\\" _c(char);                     // Literal operator for user-defined CHARACTER literal\\nReturnType operator \\\"\\\" _d(wchar_t);                  // Literal operator for user-defined CHARACTER literal\\nReturnType operator \\\"\\\" _e(char16_t);                 // Literal operator for user-defined CHARACTER literal\\nReturnType operator \\\"\\\" _f(char32_t);                 // Literal operator for user-defined CHARACTER literal\\nReturnType operator \\\"\\\" _g(const char*, size_t);      // Literal operator for user-defined STRING literal\\nReturnType operator \\\"\\\" _h(const wchar_t*, size_t);   // Literal operator for user-defined STRING literal\\nReturnType operator \\\"\\\" _i(const char16_t*, size_t);  // Literal operator for user-defined STRING literal\\nReturnType operator \\\"\\\" _g(const char32_t*, size_t);  // Literal operator for user-defined STRING literal\\nReturnType operator \\\"\\\" _r(const char*);              // Raw literal operator\\ntemplate<char...> ReturnType operator \\\"\\\" _t();       // Literal operator template\\n\")), mdx(\"br\", null), mdx(\"h4\", null, \"Cooked vs Raw literals\"), mdx(\"p\", null, \"A user-defined literal that accepts as input whatever type the compiler assigned to the literal value is unofficially known as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cooked literal\"), \".\"), mdx(\"p\", null, \"Operator defined by the user which accepts the literal as sequence of char values, then it's up to the user how to interpret the literal is called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"raw literal\"), \".\"), mdx(\"p\", null, \"Let's take a look at an example.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"#include <iostream>\\n#include <string>\\n\\ndouble operator\\\"\\\" _km(const char *km){\\n  std::cout << \\\"Raw _km\\\" << std::endl;\\n  // Converting const char* to double, requires <string>\\n  return std::stod(km);\\n}\\n\\n// Based on the signature above\\ndouble operator\\\"\\\" _m(unsigned long long meter){\\n  std::cout << \\\"Cooked _m\\\" << std::endl;\\n  return double(meter);\\n}\\n\\nint main(){\\n  auto distance_km = 100.5_km;\\n  std::cout << distance_km << std::endl;\\n  std::cout << \\\"Type: \\\" << typeid(distance_km).name() << std::endl;\\n\\n  std::cout << std::endl;\\n\\n  auto distance_m = 100_m;\\n  std::cout << distance_m << std::endl;\\n  std::cout << \\\"Type: \\\" << typeid(distance_m).name() << std::endl;\\n}\\n\")), mdx(\"br\", null), mdx(\"h4\", null, \"Output\"), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Raw _km\\n100.5\\nType: d\\n\\nCooked _m\\n100\\nType: d\\n\")), mdx(\"br\", null), mdx(\"p\", null, \"If we implement both cooked and raw both forms the compiler will use the cooked form since it has higher priority.\"), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\ndouble operator\\\"\\\" _km(const char* km){\\n    std::cout << \\\"Raw _km\\\" << std::endl;\\n    return std::stod(km);\\n}\\n\\nlong double operator\\\"\\\" _km(long double km){\\n    std::cout << \\\"Cooked _km\\\" << std::endl;\\n    return km;\\n}\\n\\nint main()\\n{\\n    auto distance_km = 100.0_km;\\n    std::cout << distance_km << std::endl;\\n}\\n\")), mdx(\"br\", null), mdx(\"h4\", null, \"Output\"), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Cooked _km\\n100\\n\")), mdx(\"br\", null), mdx(\"h3\", null, \"Usecase\"), mdx(\"p\", null, \"Always save distance as meter.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"#include <iostream>\\n#include <ostream>\\n\\nnamespace MeterDistance {\\n class Distance {\\n public:\\n    Distance (double i) : meter(i) {}\\n\\n     friend std::ostream& operator << (std::ostream& out, const Distance &a){\\n         out << a.meter << \\\" m\\\";\\n         return out;\\n     }\\n\\n private:\\n     double meter;\\n };\\n\\n namespace Unit {\\n Distance operator \\\"\\\"_km(long double d){\\n     return Distance(d * 1000);\\n }\\n }\\n}\\n\\nusing MeterDistance::Distance;\\nusing namespace MeterDistance::Unit;\\n\\nint main()\\n{\\n    Distance d(1.0_km);\\n    std::cout << d << std::endl;\\n}\\n\")), mdx(\"br\", null), mdx(\"h4\", null, \"Output\"), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"1000 m\\n\")), mdx(\"p\", null, \"In the next episode we will look at enumerators and pointers.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"I had a long dream of learning C++ properly, and due the lockdown during Covid19 pandemic I finally had the chance to review my learnings…","timeToRead":1,"banner":null}},"pageContext":{"slug":"/cpp-notes-part-1-literals","formatString":"DD.MM.YYYY"}}}